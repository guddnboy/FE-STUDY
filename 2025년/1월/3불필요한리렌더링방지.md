# 리액트에서 컴포넌트가 불필요하게 리렌더링되는 상황을 방지하기 위한 방법은 무엇이 있나요?

## `React.memo`를 활용하는 방법

`React.memo`를 활용하여 컴포넌트를 메모이제이션할 수 있습니다. 이는 컴포넌트의 props가 변경되지 않으면 컴포넌트를 리렌더링하지 않도록 합니다. 특히 부모 컴포넌트가 자주 업데이트되는 상황에서 유용합니다.

`const MemoizedComponent = React.memo(MyComponent);`

## `useMemo`와 `useCallback` 훅을 활용하는 방법

`useMemo`는 계산 비용이 많이 드는 연산 결과를, `useCallback`은 자식 컴포넌트에 전달되는 콜백 함수를 메모이제이션합니다.

```
const memoizedValue = useMemo(() => computeExpensiveValue(a,b), [a,b]);

const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);
```

## **React DevTools**의 **Profiler**를 활용하여 불필요한 리렌더링이 발생하는 컴포넌트를 식별하고 최적화할 수 있습니다.

# 그렇다면 메모이제이션은 많이 적용할 수록 성능이 좋아지는 것인가요?

무분별한 적용은 오히려 성능에 부정적인 영향을 미칠 수 있습니다. 메모이제이션도 결국 또 다른 비용이 발생하는 작업이기 때문입니다.

React는 이전 값을 메모리에 저장해야 하므로 메모리 비용이 발생하고, 의존성 배열의 각 항목을 비교하는 작업을 수행해야 하기도 합니다.

> 즉, 복잡한 계산이 필요한 경우, 컴포넌트가 자주 리렌더링되는 경우 등 성능 최적화가 필요한 경우에만 메모이제이션이 성능에 도움이 됩니다. 따라서 성능 최적화는 실제 병목이 발생하는 지점을 React DevTools Profiler로 확인하고, 선별적으로 적용하는 것이 바람직합니다.

# 몰라서 추가로 학습한 부분

## React.Memo는 무엇인가요?

`memo`를 사용하면 컴포넌트의 props가 변경되지 않은 경우 리렌더링을 건너뛸 수 있습니다. 컴포넌트를 `memo`로 감싸면 해당 컴포넌트의 memoized 버전을 얻을 수 있습니다. memoized 버전의 컴포넌트는 일반적으로 부모 컴포넌트가 리렌더링 되어도 **props가 변경되지 않았다면 리렌더링 되지 않습니다.**

`const MemoizedComponent = memo(SomeComponent, arePropsEqual?)`

### SomeComponent

memoize 하려는 컴포넌트입니다. 이 컴포넌트를 수정하지 않고 새로운 memoized 컴포넌트를 반환합니다.

### arePropsEqual (Optional)

컴포넌트의 이전 props와 새로운 props의 두 가지 인수를 받는 함수입니다. 동일한 경우 `true` 반환, 그렇지 않으면 `false`를 반환해야 합니다. React는 기본적으로 `Object.is`로 각 props를 비교합니다.

## 메모이제이션이 무엇인가요?

메모이제이션은 동일한 계산을 반복할 때, **이전에 계산했던 값들을 메모리에 저장함으로써 계산의 반복 수행을 제거**하여 프로그램 실행 속도를 빠르게 할 수 있는 방법입니다.

리액트에서는 메모이제이션 기능을 지원하는 훅(`useMemo`, `useCallback`)을 사용할 수 있습니다.

## useMemo는 어떤 훅인가요?

`useMemo`는 리액트에서 컴포넌트의 성능을 최적화 하는데 사용되는 훅입니다. 메모이제이션된 값을 가져와 재사용할 수 있게 해줍니다.

```js
const value = useMemo(() => {
  return calculate();
}, [item]);
```

첫 번째 인자로 콜백함수, 두 번째 인자로 의존성 배열을 받습니다. 의존성 배열 안에 있는 값이 업데이트 될 때에만 콜백 함수를 다시 호출하여 메모리에 저장된 값을 업데이트 해줍니다. 의존성 배열이 비어 있으면 마운트 될 때에만 값을 계산하고 그 이후론 계속 메모이제이션된 값을 꺼내와 사용합니다.

## useCallback은 어떤 훅인가요?

인자로 전달한 콜백 함수 그 자체를 메모이제이션 하는 것입니다. `useCallback`을 사용하면 컴포넌트가 다시 렌더링 되더라도, 해당 함수가 의존하고 있는 값들이 바뀌지 않는다면 함수를 새로 생성하지 않고 기존 함수를 계속 반환합니다.

```js
const calculate = useCallback(
  (num) => {
    return num + 1;
  },
  [item]
);
```

`calculate` 함수는 메모이제이션된 함수를 가지고 있게 됩니다. 메모이제이션된 `calculate`함수는 의존성 배열에 있는 값이 변경되지 않는 이상 다시 초기화되지 않습니다.

### 함수 동등성

자바스크립트에서 함수는 객체로 취급이 되기 때문에, 함수를 동일하게 만들어도 메모리 주소가 다르면 다른 함수로 간주합니다.

만약 특정 함수를 다른 함수의 인자로 넘기거나, 자식 컴포넌트의 props로 넘길 때 함수의 참조가 달라서 예상하지 못한 성능 문제가 발생할 수 있습니다. 이 경우, `useCallback`을 이용해 함수를 특정 조건이 변경되지 않는 이상 재생성하지 못하게 제한하여 함수 동등성을 보장할 수 있습니다.
